(window.webpackJsonp=window.webpackJsonp||[]).push([[225],{624:function(t,s,a){"use strict";a.r(s);var n=a(14),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_2-2-cgo-基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-cgo-基础"}},[t._v("#")]),t._v(" 2.2 CGO 基础")]),t._v(" "),s("p",[t._v("要使用 CGO 特性，需要安装 C/C++ 构建工具链，在 macOS 和 Linux 下是要安装 GCC，在 windows 下是需要安装 MinGW 工具。同时需要保证环境变量 "),s("code",[t._v("CGO_ENABLED")]),t._v(" 被设置为 1，这表示 CGO 是被启用的状态。在本地构建时 "),s("code",[t._v("CGO_ENABLED")]),t._v(" 默认是启用的，当交叉构建时 CGO 默认是禁止的。比如要交叉构建 ARM 环境运行的 Go 程序，需要手工设置好 C/C++ 交叉构建的工具链，同时开启 "),s("code",[t._v("CGO_ENABLED")]),t._v(" 环境变量。然后通过 "),s("code",[t._v('import "C"')]),t._v(" 语句启用 CGO 特性。")]),t._v(" "),s("h2",{attrs:{id:"_2-2-1-import-c-语句"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-import-c-语句"}},[t._v("#")]),t._v(" 2.2.1 "),s("code",[t._v('import "C"')]),t._v(" 语句")]),t._v(" "),s("p",[t._v("如果在 Go 代码中出现了 "),s("code",[t._v('import "C"')]),t._v(" 语句则表示使用了 CGO 特性，紧跟在这行语句前面的注释是一种特殊语法，里面包含的是正常的 C 语言代码。当确保 CGO 启用的情况下，还可以在当前目录中包含 C/C++ 对应的源文件。")]),t._v(" "),s("p",[t._v("举个最简单的例子：")]),t._v(" "),s("div",{staticClass:"language-Go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" main\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/*\n#include <stdio.h>\n\nvoid printint(int v) {\n\tprintf("printint: %d\\n", v);\n}\n*/')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"C"')]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tv "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),t._v("\n\tC"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("printint")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("C"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v('这个例子展示了 cgo 的基本使用方法。开头的注释中写了要调用的 C 函数和相关的头文件，头文件被 include 之后里面的所有的 C 语言元素都会被加入到”C” 这个虚拟的包中。需要注意的是，import "C" 导入语句需要单独一行，不能与其他包一同 import。向 C 函数传递参数也很简单，就直接转化成对应 C 语言类型传递就可以。如上例中 '),s("code",[t._v("C.int(v)")]),t._v(" 用于将一个 Go 中的 int 类型值强制类型转换转化为 C 语言中的 int 类型值，然后调用 C 语言定义的 printint 函数进行打印。")]),t._v(" "),s("p",[t._v("需要注意的是，Go 是强类型语言，所以 cgo 中传递的参数类型必须与声明的类型完全一致，而且传递前必须用”C” 中的转化函数转换成对应的 C 类型，不能直接传入 Go 中类型的变量。同时通过虚拟的 C 包导入的 C 语言符号并不需要是大写字母开头，它们不受 Go 语言的导出规则约束。")]),t._v(" "),s("p",[t._v("cgo 将当前包引用的 C 语言符号都放到了虚拟的 C 包中，同时当前包依赖的其它 Go 语言包内部可能也通过 cgo 引入了相似的虚拟 C 包，但是不同的 Go 语言包引入的虚拟的 C 包之间的类型是不能通用的。这个约束对于要自己构造一些 cgo 辅助函数时有可能会造成一点的影响。")]),t._v(" "),s("p",[t._v("比如我们希望在 Go 中定义一个 C 语言字符指针对应的 CChar 类型，然后增加一个 GoString 方法返回 Go 语言字符串：")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" cgo_helper\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//#include <stdio.h>")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"C"')]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" CChar C"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("char\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("CChar"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("GoString")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" C"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("GoString")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("C"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("char"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("PrintCString")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cs "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("C"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("char"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tC"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("puts")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("现在我们可能会想在其它的 Go 语言包中也使用这个辅助函数：")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" main\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('//static const char* cs = "hello";')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"C"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"./cgo_helper"')]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tcgo_helper"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("PrintCString")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("C"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("cs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("这段代码是不能正常工作的，因为当前 main 包引入的 "),s("code",[t._v("C.cs")]),t._v(" 变量的类型是当前 "),s("code",[t._v("main")]),t._v(" 包的 cgo 构造的虚拟的 C 包下的 "),s("code",[t._v("*char")]),t._v(" 类型（具体点是 "),s("code",[t._v("*C.char")]),t._v("，更具体点是 "),s("code",[t._v("*main.C.char")]),t._v("），它和 cgo_helper 包引入的 "),s("code",[t._v("*C.char")]),t._v(" 类型（具体点是 "),s("code",[t._v("*cgo_helper.C.char")]),t._v("）是不同的。在 Go 语言中方法是依附于类型存在的，不同 Go 包中引入的虚拟的 C 包的类型却是不同的（"),s("code",[t._v("main.C")]),t._v(" 不等 "),s("code",[t._v("cgo_helper.C")]),t._v("），这导致从它们延伸出来的 Go 类型也是不同的类型（"),s("code",[t._v("*main.C.char")]),t._v(" 不等 "),s("code",[t._v("*cgo_helper.C.char")]),t._v("），这最终导致了前面代码不能正常工作。")]),t._v(" "),s("p",[t._v("有 Go 语言使用经验的用户可能会建议参数转型后再传入。但是这个方法似乎也是不可行的，因为 "),s("code",[t._v("cgo_helper.PrintCString")]),t._v(" 的参数是它自身包引入的 "),s("code",[t._v("*C.char")]),t._v(" 类型，在外部是无法直接获取这个类型的。换言之，一个包如果在公开的接口中直接使用了 "),s("code",[t._v("*C.char")]),t._v(" 等类似的虚拟 C 包的类型，其它的 Go 包是无法直接使用这些类型的，除非这个 Go 包同时也提供了 "),s("code",[t._v("*C.char")]),t._v(" 类型的构造函数。因为这些诸多因素，如果想在 go test 环境直接测试这些 cgo 导出的类型也会有相同的限制。")]),t._v(" "),s("h2",{attrs:{id:"_2-2-2-cgo-语句"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-cgo-语句"}},[t._v("#")]),t._v(" 2.2.2 "),s("code",[t._v("#cgo")]),t._v(" 语句")]),t._v(" "),s("p",[t._v("在 "),s("code",[t._v('import "C"')]),t._v(" 语句前的注释中可以通过 "),s("code",[t._v("#cgo")]),t._v(" 语句设置编译阶段和链接阶段的相关参数。编译阶段的参数主要用于定义相关宏和指定头文件检索路径。链接阶段的参数主要是指定库文件检索路径和要链接的库文件。")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// #cgo CFLAGS: -DPNG_DEBUG=1 -I./include")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// #cgo LDFLAGS: -L/usr/local/lib -lpng")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// #include <png.h>")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"C"')]),t._v("\n")])])]),s("p",[t._v("上面的代码中，CFLAGS 部分，"),s("code",[t._v("-D")]),t._v(" 部分定义了宏 PNG_DEBUG，值为 1；"),s("code",[t._v("-I")]),t._v(" 定义了头文件包含的检索目录。LDFLAGS 部分，"),s("code",[t._v("-L")]),t._v(" 指定了链接时库文件检索目录，"),s("code",[t._v("-l")]),t._v(" 指定了链接时需要链接 png 库。")]),t._v(" "),s("p",[t._v("因为 C/C++ 遗留的问题，C 头文件检索目录可以是相对目录，但是库文件检索目录则需要绝对路径。在库文件的检索目录中可以通过 "),s("code",[t._v("${SRCDIR}")]),t._v(" 变量表示当前包目录的绝对路径：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// #cgo LDFLAGS: -L${SRCDIR}/libs -lfoo\n")])])]),s("p",[t._v("上面的代码在链接时将被展开为：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// #cgo LDFLAGS: -L/go/src/foo/libs -lfoo\n")])])]),s("p",[s("code",[t._v("#cgo")]),t._v(" 语句主要影响 CFLAGS、CPPFLAGS、CXXFLAGS、FFLAGS 和 LDFLAGS 几个编译器环境变量。LDFLAGS 用于设置链接时的参数，除此之外的几个变量用于改变编译阶段的构建参数 (CFLAGS 用于针对 C 语言代码设置编译参数)。")]),t._v(" "),s("p",[t._v("对于在 cgo 环境混合使用 C 和 C++ 的用户来说，可能有三种不同的编译选项：其中 CFLAGS 对应 C 语言特有的编译选项、CXXFLAGS 对应是 C++ 特有的编译选项、CPPFLAGS 则对应 C 和 C++ 共有的编译选项。但是在链接阶段，C 和 C++ 的链接选项是通用的，因此这个时候已经不再有 C 和 C++ 语言的区别，它们的目标文件的类型是相同的。")]),t._v(" "),s("p",[s("code",[t._v("#cgo")]),t._v(" 指令还支持条件选择，当满足某个操作系统或某个 CPU 架构类型时后面的编译或链接选项生效。比如下面是分别针对 windows 和非 windows 下平台的编译和链接选项：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// #cgo windows CFLAGS: -DX86=1\n// #cgo !windows LDFLAGS: -lm\n")])])]),s("p",[t._v("其中在 windows 平台下，编译前会预定义 X86 宏为 1；在非 windows 平台下，在链接阶段会要求链接 math 数学库。这种用法对于在不同平台下只有少数编译选项差异的场景比较适用。")]),t._v(" "),s("p",[t._v("如果在不同的系统下 cgo 对应着不同的 c 代码，我们可以先使用 "),s("code",[t._v("#cgo")]),t._v(" 指令定义不同的 C 语言的宏，然后通过宏来区分不同的代码：")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" main\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/*\n#cgo windows CFLAGS: -DCGO_OS_WINDOWS=1\n#cgo darwin CFLAGS: -DCGO_OS_DARWIN=1\n#cgo linux CFLAGS: -DCGO_OS_LINUX=1\n\n#if defined(CGO_OS_WINDOWS)\n\tconst char* os = "windows";\n#elif defined(CGO_OS_DARWIN)\n\tconst char* os = "darwin";\n#elif defined(CGO_OS_LINUX)\n\tconst char* os = "linux";\n#else\n#\terror(unknown os)\n#endif\n*/')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"C"')]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("C"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("GoString")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("C"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("os"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("这样我们就可以用 C 语言中常用的技术来处理不同平台之间的差异代码。")]),t._v(" "),s("h2",{attrs:{id:"_2-2-3-build-tag-条件编译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-build-tag-条件编译"}},[t._v("#")]),t._v(" 2.2.3 build tag 条件编译")]),t._v(" "),s("p",[t._v("build tag 是在 Go 或 cgo 环境下的 C/C++ 文件开头的一种特殊的注释。条件编译类似于前面通过 "),s("code",[t._v("#cgo")]),t._v(" 指令针对不同平台定义的宏，只有在对应平台的宏被定义之后才会构建对应的代码。但是通过 "),s("code",[t._v("#cgo")]),t._v(" 指令定义宏有个限制，它只能是基于 Go 语言支持的 windows、darwin 和 linux 等已经支持的操作系统。如果我们希望定义一个 DEBUG 标志的宏，"),s("code",[t._v("#cgo")]),t._v(" 指令就无能为力了。而 Go 语言提供的 build tag 条件编译特性则可以简单做到。")]),t._v(" "),s("p",[t._v("比如下面的源文件只有在设置 debug 构建标志时才会被构建：")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// +build debug")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" main\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" buildMode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"debug"')]),t._v("\n")])])]),s("p",[t._v("可以用以下命令构建：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('go build -tags="debug"\ngo build -tags="windows debug"\n')])])]),s("p",[t._v("我们可以通过 "),s("code",[t._v("-tags")]),t._v(" 命令行参数同时指定多个 build 标志，它们之间用空格分隔。")]),t._v(" "),s("p",[t._v("当有多个 build tag 时，我们将多个标志通过逻辑操作的规则来组合使用。比如以下的构建标志表示只有在”linux/386“或”darwin 平台下非 cgo 环境 “才进行构建。")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// +build linux,386 darwin,!cgo")]),t._v("\n")])])]),s("p",[t._v("其中 "),s("code",[t._v("linux,386")]),t._v(" 中 linux 和 386 用逗号链接表示 AND 的意思；而 "),s("code",[t._v("linux,386")]),t._v(" 和 "),s("code",[t._v("darwin,!cgo")]),t._v(" 之间通过空白分割来表示 OR 的意思。")])])}),[],!1,null,null,null);s.default=e.exports}}]);