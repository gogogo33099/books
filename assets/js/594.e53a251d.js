(window.webpackJsonp=window.webpackJsonp||[]).push([[594],{1070:function(t,s,a){"use strict";a.r(s);var n=a(14),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_9-3-锁和-sync-包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-锁和-sync-包"}},[t._v("#")]),t._v(" 9.3 锁和 sync 包")]),t._v(" "),s("p",[t._v("在一些复杂的程序中，通常通过不同线程执行不同应用来实现程序的并发。当不同线程要使用同一个变量时，经常会出现一个问题：无法预知变量被不同线程修改的顺序！（这通常被称为资源竞争，指不同线程对同一变量使用的竞争）显然这无法让人容忍，那我们该如何解决这个问题呢？")]),t._v(" "),s("p",[t._v("经典的做法是一次只能让一个线程对共享变量进行操作。当变量被一个线程改变时（临界区），我们为它上锁，直到这个线程执行完成并解锁后，其他线程才能访问它。")]),t._v(" "),s("p",[t._v("特别是我们之前章节学习的 "),s("code",[t._v("map")]),t._v(" 类型是不存在锁的机制来实现这种效果（出于对性能的考虑），所以 map 类型是非线程安全的。当并行访问一个共享的 "),s("code",[t._v("map")]),t._v(" 类型的数据，"),s("code",[t._v("map")]),t._v(" 数据将会出错。")]),t._v(" "),s("p",[t._v("在 Go 语言中这种锁的机制是通过 "),s("code",[t._v("sync")]),t._v(" 包中 "),s("code",[t._v("Mutex")]),t._v(' 来实现的。sync 来源于 "synchronized" 一词，这意味着线程将有序的对同一变量进行访问。')]),t._v(" "),s("p",[s("code",[t._v("sync.Mutex")]),t._v(" 是一个互斥锁，它的作用是守护在临界区入口来确保同一时间只能有一个线程进入临界区。")]),t._v(" "),s("p",[t._v("假设 "),s("code",[t._v("info")]),t._v(" 是一个需要上锁的放在共享内存中的变量。通过包含 "),s("code",[t._v("Mutex")]),t._v(" 来实现的一个典型例子如下：")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"sync"')]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Info "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tmu sync"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Mutex\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ... other fields, e.g.: Str string")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("如果一个函数想要改变这个变量可以这样写:")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Update")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("info "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("Info"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tinfo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("mu"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Lock")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// critical section:")]),t._v("\n    info"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Str "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// new value")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// end critical section")]),t._v("\n    info"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("mu"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Unlock")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("还有一个很有用的例子是通过 "),s("code",[t._v("Mutex")]),t._v(" 来实现一个可以上锁的共享缓冲器:")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" SyncedBuffer "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tlock \tsync"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Mutex\n\tbuffer  bytes"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Buffer\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("在 "),s("code",[t._v("sync")]),t._v(" 包中还有一个 "),s("code",[t._v("RWMutex")]),t._v(" 锁：它能通过 "),s("code",[t._v("RLock()")]),t._v(" 来允许同一时间多个线程对变量进行读操作，但是只能一个线程进行写操作。如果使用 "),s("code",[t._v("Lock()")]),t._v(" 将和普通的 "),s("code",[t._v("Mutex")]),t._v(" 作用相同。包中还有一个方便的 "),s("code",[t._v("Once")]),t._v(" 类型变量的方法 "),s("code",[t._v("once.Do(call)")]),t._v("，这个方法确保被调用函数只能被调用一次。")]),t._v(" "),s("p",[t._v("相对简单的情况下，通过使用 "),s("code",[t._v("sync")]),t._v(" 包可以解决同一时间只能一个线程访问变量或 "),s("code",[t._v("map")]),t._v(" 类型数据的问题。如果这种方式导致程序明显变慢或者引起其他问题，我们要重新思考来通过 goroutines 和 channels 来解决问题，这是在 Go 语言中所提倡用来实现并发的技术。我们将在"),s("RouterLink",{attrs:{to:"/the-way-to-go/14.0.html"}},[t._v("第 14 章")]),t._v("对其深入了解，并在"),s("RouterLink",{attrs:{to:"/the-way-to-go/14.7.html"}},[t._v("第 14.7 节")]),t._v("中对这两种方式进行比较。")],1),t._v(" "),s("h2",{attrs:{id:"链接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链接"}},[t._v("#")]),t._v(" 链接")]),t._v(" "),s("ul",[s("li",[s("RouterLink",{attrs:{to:"/the-way-to-go/directory.html"}},[t._v("目录")])],1),t._v(" "),s("li",[t._v("上一节："),s("RouterLink",{attrs:{to:"/the-way-to-go/09.2.html"}},[t._v("regexp 包")])],1),t._v(" "),s("li",[t._v("下一节："),s("RouterLink",{attrs:{to:"/the-way-to-go/09.4.html"}},[t._v("精密计算和 big 包")])],1)])])}),[],!1,null,null,null);s.default=e.exports}}]);