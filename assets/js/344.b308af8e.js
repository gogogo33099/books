(window.webpackJsonp=window.webpackJsonp||[]).push([[344],{782:function(t,s,n){"use strict";n.r(s);var r=n(14),a=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"第7章-接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第7章-接口"}},[t._v("#")]),t._v(" 第7章　接口")]),t._v(" "),s("p",[t._v("接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。")]),t._v(" "),s("p",[t._v("很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用。")]),t._v(" "),s("p",[t._v("在本章，我们会开始看到接口类型和值的一些基本技巧。顺着这种方式我们将学习几个来自标准库的重要接口。很多Go程序中都尽可能多的去使用标准库中的接口。最后，我们会在（§7.10）看到类型断言的知识，在（§7.13）看到类型开关的使用并且学到他们是怎样让不同的类型的概括成为可能。")])])}),[],!1,null,null,null);s.default=a.exports}}]);