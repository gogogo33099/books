(window.webpackJsonp=window.webpackJsonp||[]).push([[153],{546:function(a,s,t){"use strict";t.r(s);var e=t(14),r=Object(e.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"命名管道"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#命名管道"}},[a._v("#")]),a._v(" 命名管道")]),a._v(" "),s("p",[a._v("在大多数类似 Unix 的操作系统中，有可能创建一种特殊类型的文件，叫做命名管道。命名管道用来在 两个进程之间建立连接，也可以像其它类型的文件一样使用。")]),a._v(" "),s("p",[a._v("命令管道的行为类似于文件，但实际上形成了先入先出（FIFO）的缓冲。和普通（未命令的）管道一样， 数据从一端进入，然后从另一端出现。通过命令管道，有可能像这样设置一些东西：")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("process1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" named_pipe\n")])])]),s("p",[a._v("和")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("process2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" named_pipe\n")])])]),s("p",[a._v("表现出来就像这样：")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("process1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" process2\n")])])]),s("h2",{attrs:{id:"设置一个命名管道"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设置一个命名管道"}},[a._v("#")]),a._v(" 设置一个命名管道")]),a._v(" "),s("p",[a._v("使用 mkfifo 命令能够创建命令管道：")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("mkfifo")]),a._v(" pipe1\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("ls")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-l")]),a._v(" pipe1\nprw-r--r-- "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" me me "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2009")]),a._v("-07-17 06:41 pipe1\n")])])]),s("p",[a._v("这里我们使用 mkfifo 创建了一个名为 pipe1 的命名管道。使用 ls 命令，我们查看这个文件， 看到位于属性字段的第一个字母是 “p”，表明它是一个命名管道。")]),a._v(" "),s("h2",{attrs:{id:"使用命名管道"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用命名管道"}},[a._v("#")]),a._v(" 使用命名管道")]),a._v(" "),s("p",[a._v("为了演示命名管道是如何工作的，我们将需要两个终端窗口（或用两个虚拟控制台代替）。 在第一个终端中，我们输入一个简单命令，并把命令的输出重定向到命名管道：")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("ls")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-l")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" pipe1\n")])])]),s("p",[a._v("我们按下 Enter 按键之后，命令将会挂起。这是因为在管道的另一端没有任何接受数据。当这种现象发生的时候， 据说是管道阻塞了。一旦我们绑定一个进程到管道的另一端，该进程开始从管道中读取输入的时候，这种情况会消失。 使用第二个终端窗口，我们输入这个命令。")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("cat")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" pipe1\n")])])]),s("p",[a._v("然后产自第一个终端窗口的目录列表出现在第二个终端中，并作为来自 cat 命令的输出。在第一个终端 窗口中的 ls 命令一旦它不再阻塞，会成功地结束。")])])}),[],!1,null,null,null);s.default=r.exports}}]);