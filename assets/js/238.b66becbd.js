(window.webpackJsonp=window.webpackJsonp||[]).push([[238],{645:function(n,a,t){"use strict";t.r(a);var s=t(14),e=Object(s.a)({},(function(){var n=this,a=n._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"_3-9-delve-调试器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-9-delve-调试器"}},[n._v("#")]),n._v(" 3.9 Delve 调试器")]),n._v(" "),a("p",[n._v("目前 Go 语言支持 GDB、LLDB 和 Delve 几种调试器。其中 GDB 是最早支持的调试工具，LLDB 是 macOS 系统推荐的标准调试工具。但是 GDB 和 LLDB 对 Go 语言的专有特性都缺乏很大支持，而只有 Delve 是专门为 Go 语言设计开发的调试工具。而且 Delve 本身也是采用 Go 语言开发，对 Windows 平台也提供了一样的支持。本节我们基于 Delve 简单解释如何调试 Go 汇编程序。")]),n._v(" "),a("h2",{attrs:{id:"_3-9-1-delve-入门"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-9-1-delve-入门"}},[n._v("#")]),n._v(" 3.9.1 Delve 入门")]),n._v(" "),a("p",[n._v("首先根据官方的文档正确安装 Delve 调试器。我们会先构造一个简单的 Go 语言代码，用于熟悉下 Delve 的简单用法。")]),n._v(" "),a("p",[n._v("创建 main.go 文件，main 函数先通过循初始化一个切片，然后输出切片的内容：")]),n._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("package")]),n._v(" main\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("import")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("\n\t"),a("span",{pre:!0,attrs:{class:"token string"}},[n._v('"fmt"')]),n._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("func")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[n._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n\tnums "),a("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":=")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[n._v("make")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[n._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[n._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("for")]),n._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":=")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[n._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[n._v("<")]),a("span",{pre:!0,attrs:{class:"token function"}},[n._v("len")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("nums"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[n._v("++")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n\t\tnums"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("[")]),n._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("]")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[n._v("*")]),n._v(" i\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n\tfmt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[n._v("Println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("nums"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n")])])]),a("p",[n._v("命令行进入包所在目录，然后输入 "),a("code",[n._v("dlv debug")]),n._v(" 命令进入调试：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("$ dlv debug\nType 'help' for list of commands.\n(dlv)\n")])])]),a("p",[n._v("输入 help 命令可以查看到 Delve 提供的调试命令列表：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("(dlv) help\nThe following commands are available:\n    args ------------------------ Print function arguments.\n    break (alias: b) ------------ Sets a breakpoint.\n    breakpoints (alias: bp) ----- Print out info for active breakpoints.\n    clear ----------------------- Deletes breakpoint.\n    clearall -------------------- Deletes multiple breakpoints.\n    condition (alias: cond) ----- Set breakpoint condition.\n    config ---------------------- Changes configuration parameters.\n    continue (alias: c) --------- Run until breakpoint or program termination.\n    disassemble (alias: disass) - Disassembler.\n    down ------------------------ Move the current frame down.\n    exit (alias: quit | q) ------ Exit the debugger.\n    frame ----------------------- Set the current frame, or execute command...\n    funcs ----------------------- Print list of functions.\n    goroutine ------------------- Shows or changes current goroutine\n    goroutines ------------------ List program goroutines.\n    help (alias: h) ------------- Prints the help message.\n    list (alias: ls | l) -------- Show source code.\n    locals ---------------------- Print local variables.\n    next (alias: n) ------------- Step over to next source line.\n    on -------------------------- Executes a command when a breakpoint is hit.\n    print (alias: p) ------------ Evaluate an expression.\n    regs ------------------------ Print contents of CPU registers.\n    restart (alias: r) ---------- Restart process.\n    set ------------------------- Changes the value of a variable.\n    source ---------------------- Executes a file containing a list of delve...\n    sources --------------------- Print list of source files.\n    stack (alias: bt) ----------- Print stack trace.\n    step (alias: s) ------------- Single step through program.\n    step-instruction (alias: si)  Single step a single cpu instruction.\n    stepout --------------------- Step out of the current function.\n    thread (alias: tr) ---------- Switch to the specified thread.\n    threads --------------------- Print out info for every traced thread.\n    trace (alias: t) ------------ Set tracepoint.\n    types ----------------------- Print list of types\n    up -------------------------- Move the current frame up.\n    vars ------------------------ Print package variables.\n    whatis ---------------------- Prints type of an expression.\nType help followed by a command for full documentation.\n(dlv)\n")])])]),a("p",[n._v("每个 Go 程序的入口是 main.main 函数，我们可以用 break 在此设置一个断点：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("(dlv) break main.main\nBreakpoint 1 set at 0x10ae9b8 for main.main() ./main.go:7\n")])])]),a("p",[n._v("然后通过 breakpoints 查看已经设置的所有断点：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("(dlv) breakpoints\nBreakpoint unrecovered-panic at 0x102a380 for runtime.startpanic()\n    /usr/local/go/src/runtime/panic.go:588 (0)\n        print runtime.curg._panic.arg\nBreakpoint 1 at 0x10ae9b8 for main.main() ./main.go:7 (0)\n")])])]),a("p",[n._v("我们发现除了我们自己设置的 main.main 函数断点外，Delve 内部已经为 panic 异常函数设置了一个断点。")]),n._v(" "),a("p",[n._v("通过 vars 命令可以查看全部包级的变量。因为最终的目标程序可能含有大量的全局变量，我们可以通过一个正则参数选择想查看的全局变量：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("(dlv) vars main\nmain.initdone· = 2\nruntime.main_init_done = chan bool 0/0\nruntime.mainStarted = true\n(dlv)\n")])])]),a("p",[n._v("然后就可以通过 continue 命令让程序运行到下一个断点处：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('(dlv) continue\n> main.main() ./main.go:7 (hits goroutine(1):1 total:1) (PC: 0x10ae9b8)\n     2:\n     3: import (\n     4:         "fmt"\n     5: )\n     6:\n=>   7: func main() {\n     8:         nums := make([]int, 5)\n     9:         for i := 0; i <len(nums); i++ {\n    10:                 nums[i] = i * i\n    11:         }\n    12:         fmt.Println(nums)\n(dlv)\n')])])]),a("p",[n._v("输入 next 命令单步执行进入 main 函数内部：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('(dlv) next\n> main.main() ./main.go:8 (PC: 0x10ae9cf)\n     3: import (\n     4:         "fmt"\n     5: )\n     6:\n     7: func main() {\n=>   8:         nums := make([]int, 5)\n     9:         for i := 0; i <len(nums); i++ {\n    10:                 nums[i] = i * i\n    11:         }\n    12:         fmt.Println(nums)\n    13: }\n(dlv)\n')])])]),a("p",[n._v("进入函数之后可以通过 args 和 locals 命令查看函数的参数和局部变量：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("(dlv) args\n(no args)\n(dlv) locals\nnums = []int len: 842350763880, cap: 17491881, nil\n")])])]),a("p",[n._v("因为 main 函数没有参数，因此 args 命令没有任何输出。而 locals 命令则输出了局部变量 nums 切片的值：此时切片还未完成初始化，切片的底层指针为 nil，长度和容量都是一个随机数值。")]),n._v(" "),a("p",[n._v("再次输入 next 命令单步执行后就可以查看到 nums 切片初始化之后的结果了：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('(dlv) next\n> main.main() ./main.go:9 (PC: 0x10aea12)\n     4:         "fmt"\n     5: )\n     6:\n     7: func main() {\n     8:         nums := make([]int, 5)\n=>   9:         for i := 0; i <len(nums); i++ {\n    10:                 nums[i] = i * i\n    11:         }\n    12:         fmt.Println(nums)\n    13: }\n(dlv) locals\nnums = []int len: 5, cap: 5, [...]\ni = 17601536\n(dlv)\n')])])]),a("p",[n._v("此时因为调试器已经到了 for 语句行，因此局部变量出现了还未初始化的循环迭代变量 i。")]),n._v(" "),a("p",[n._v("下面我们通过组合使用 break 和 condition 命令，在循环内部设置一个条件断点，当循环变量 i 等于 3 时断点生效：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("(dlv) break main.go:10\nBreakpoint 2 set at 0x10aea33 for main.main() ./main.go:10\n(dlv) condition 2 i==3\n(dlv)\n")])])]),a("p",[n._v("然后通过 continue 执行到刚设置的条件断点，并且输出局部变量：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("(dlv) continue\n> main.main() ./main.go:10 (hits goroutine(1):1 total:1) (PC: 0x10aea33)\n     5: )\n     6:\n     7: func main() {\n     8:         nums := make([]int, 5)\n     9:         for i := 0; i <len(nums); i++ {\n=>  10:                 nums[i] = i * i\n    11:         }\n    12:         fmt.Println(nums)\n    13: }\n(dlv) locals\nnums = []int len: 5, cap: 5, [...]\ni = 3\n(dlv) print nums\n[]int len: 5, cap: 5, [0,1,4,0,0]\n(dlv)\n")])])]),a("p",[n._v("我们发现当循环变量 i 等于 3 时，nums 切片的前 3 个元素已经正确初始化。")]),n._v(" "),a("p",[n._v("我们还可以通过 stack 查看当前执行函数的栈帧信息：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("(dlv) stack\n0  0x00000000010aea33 in main.main\n   at ./main.go:10\n1  0x000000000102bd60 in runtime.main\n   at /usr/local/go/src/runtime/proc.go:198\n2  0x0000000001053bd1 in runtime.goexit\n   at /usr/local/go/src/runtime/asm_amd64.s:2361\n(dlv)\n")])])]),a("p",[n._v("或者通过 goroutine 和 goroutines 命令查看当前 Goroutine 相关的信息：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("(dlv) goroutine\nThread 101686 at ./main.go:10\nGoroutine 1:\n  Runtime: ./main.go:10 main.main (0x10aea33)\n  User: ./main.go:10 main.main (0x10aea33)\n  Go: /usr/local/go/src/runtime/asm_amd64.s:258 runtime.rt0_go (0x1051643)\n  Start: /usr/local/go/src/runtime/proc.go:109 runtime.main (0x102bb90)\n(dlv) goroutines\n[4 goroutines]\n* Goroutine 1 - User: ./main.go:10 main.main (0x10aea33) (thread 101686)\n  Goroutine 2 - User: /usr/local/go/src/runtime/proc.go:292 \\\n                runtime.gopark (0x102c189)\n  Goroutine 3 - User: /usr/local/go/src/runtime/proc.go:292 \\\n                runtime.gopark (0x102c189)\n  Goroutine 4 - User: /usr/local/go/src/runtime/proc.go:292 \\\n                runtime.gopark (0x102c189)\n(dlv)\n")])])]),a("p",[n._v("最后完成调试工作后输入 quit 命令退出调试器。至此我们已经掌握了 Delve 调试器器的简单用法。")]),n._v(" "),a("h2",{attrs:{id:"_3-9-2-调试汇编程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-9-2-调试汇编程序"}},[n._v("#")]),n._v(" 3.9.2 调试汇编程序")]),n._v(" "),a("p",[n._v("用 Delve 调试 Go 汇编程序的过程比调试 Go 语言程序更加简单。调试汇编程序时，我们需要时刻关注寄存器的状态，如果涉及函数调用或局部变量或参数还需要重点关注栈寄存器 SP 的状态。")]),n._v(" "),a("p",[n._v("为了编译演示，我们重新实现一个更简单的 main 函数：")]),n._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("package")]),n._v(" main\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("func")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[n._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[n._v("asmSayHello")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("func")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[n._v("asmSayHello")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n")])])]),a("p",[n._v("在 main 函数中调用汇编语言实现的 asmSayHello 函数输出一个字符串。")]),n._v(" "),a("p",[n._v("asmSayHello 函数在 main_amd64.s 文件中实现：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('#include "textflag.h"\n#include "funcdata.h"\n\n// "Hello World!\\n"\nDATA  text<>+0(SB)/8,$"Hello Wo"\nDATA  text<>+8(SB)/8,$"rld!\\n"\nGLOBL text<>(SB),NOPTR,$16\n\n// func asmSayHello()\nTEXT ·asmSayHello(SB), $16-0\n\tNO_LOCAL_POINTERS\n\tMOVQ $text<>+0(SB), AX\n\tMOVQ AX, (SP)\n\tMOVQ $16, 8(SP)\n\tCALL runtime·printstring(SB)\n\tRET\n')])])]),a("p",[n._v("参考前面的调试流程，在执行到 main 函数断点时，可以 disassemble 反汇编命令查看 main 函数对应的汇编代码：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("(dlv) break main.main\nBreakpoint 1 set at 0x105011f for main.main() ./main.go:3\n(dlv) continue\n> main.main() ./main.go:3 (hits goroutine(1):1 total:1) (PC: 0x105011f)\n  1: package main\n  2:\n=>3: func main() { asmSayHello() }\n  4:\n  5: func asmSayHello()\n(dlv) disassemble\nTEXT main.main(SB) /path/to/pkg/main.go\n  main.go:3 0x1050110  65488b0c25a0080000 mov rcx, qword ptr g  [0x8a0]\n  main.go:3 0x1050119  483b6110           cmp rsp, qword ptr [r  +0x10]\n  main.go:3 0x105011d  761a               jbe 0x1050139\n=>main.go:3 0x105011f* 4883ec08           sub rsp, 0x8\n  main.go:3 0x1050123  48892c24           mov qword ptr [rsp], rbp\n  main.go:3 0x1050127  488d2c24           lea rbp, ptr [rsp]\n  main.go:3 0x105012b  e880000000         call $main.asmSayHello\n  main.go:3 0x1050130  488b2c24           mov rbp, qword ptr [rsp]\n  main.go:3 0x1050134  4883c408           add rsp, 0x8\n  main.go:3 0x1050138  c3                 ret\n  main.go:3 0x1050139  e87288ffff         call $runtime.morestack_noctxt\n  main.go:3 0x105013e  ebd0               jmp $main.main\n(dlv)\n")])])]),a("p",[n._v("虽然 main 函数内部只有一行函数调用语句，但是却生成了很多汇编指令。在函数的开头通过比较 rsp 寄存器判断栈空间是否不足，如果不足则跳转到 0x1050139 地址调用 runtime.morestack 函数进行栈扩容，然后跳回到 main 函数开始位置重新进行栈空间测试。而在 asmSayHello 函数调用之前，先扩展 rsp 空间用于临时存储 rbp 寄存器的状态，在函数返回后通过栈恢复 rbp 的值并回收临时栈空间。通过对比 Go 语言代码和对应的汇编代码，我们可以加深对 Go 汇编语言的理解。")]),n._v(" "),a("p",[n._v("从汇编语言角度深刻 Go 语言各种特性的工作机制对调试工作也是一个很大的帮助。如果希望在汇编指令层面调试 Go 代码，Delve 还提供了一个 step-instruction 单步执行汇编指令的命令。")]),n._v(" "),a("p",[n._v("现在我们依然用 break 命令在 asmSayHello 函数设置断点，并且输入 continue 命令让调试器执行到断点位置停下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('(dlv) break main.asmSayHello\nBreakpoint 2 set at 0x10501bf for main.asmSayHello() ./main_amd64.s:10\n(dlv) continue\n> main.asmSayHello() ./main_amd64.s:10 (hits goroutine(1):1 total:1) (PC: 0x10501bf)\n     5: DATA  text<>+0(SB)/8,$"Hello Wo"\n     6: DATA  text<>+8(SB)/8,$"rld!\\n"\n     7: GLOBL text<>(SB),NOPTR,$16\n     8:\n     9: // func asmSayHello()\n=>  10: TEXT ·asmSayHello(SB), $16-0\n    11:         NO_LOCAL_POINTERS\n    12:         MOVQ $text<>+0(SB), AX\n    13:         MOVQ AX, (SP)\n    14:         MOVQ $16, 8(SP)\n    15:         CALL runtime·printstring(SB)\n(dlv)\n')])])]),a("p",[n._v("此时我们可以通过 regs 查看全部的寄存器状态：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("(dlv) regs\n       rax = 0x0000000001050110\n       rbx = 0x0000000000000000\n       rcx = 0x000000c420000300\n       rdx = 0x0000000001070be0\n       rdi = 0x000000c42007c020\n       rsi = 0x0000000000000001\n       rbp = 0x000000c420049f78\n       rsp = 0x000000c420049f70\n        r8 = 0x7fffffffffffffff\n        r9 = 0xffffffffffffffff\n       r10 = 0x0000000000000100\n       r11 = 0x0000000000000286\n       r12 = 0x000000c41fffff7c\n       r13 = 0x0000000000000000\n       r14 = 0x0000000000000178\n       r15 = 0x0000000000000004\n       rip = 0x00000000010501bf\n    rflags = 0x0000000000000206\n...\n(dlv)\n")])])]),a("p",[n._v("因为 AMD64 的各种寄存器非常多，项目的信息中刻意省略了非通用的寄存器。如果再单步执行到 13 行时，可以发现 AX 寄存器值的变化。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("(dlv) regs\n       rax = 0x00000000010a4060\n       rbx = 0x0000000000000000\n       rcx = 0x000000c420000300\n...\n(dlv)\n")])])]),a("p",[n._v("因此我们可以推断汇编程序内部定义的 "),a("code",[n._v("text<>")]),n._v(" 数据的地址为 0x00000000010a4060。我们可以用过 print 命令来查看该内存内的数据：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("(dlv) print *(*[5]byte)(uintptr(0x00000000010a4060))\n[5]uint8 [72,101,108,108,111]\n(dlv)\n")])])]),a("p",[n._v("我们可以发现输出的 "),a("code",[n._v("[5]uint8 [72,101,108,108,111]")]),n._v(" 刚好是对应 “Hello” 字符串。通过类似的方法，我们可以通过查看 SP 对应的栈指针位置，然后查看栈中局部变量的值。")]),n._v(" "),a("p",[n._v("至此我们就掌握了 Go 汇编程序的简单调试技术。")])])}),[],!1,null,null,null);a.default=e.exports}}]);